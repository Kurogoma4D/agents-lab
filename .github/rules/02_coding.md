# コーディングプラクティス

## 原則（バックエンド）

### ドメイン駆動設計 (DDD)

- 値オブジェクトとエンティティを区別
- 集約で整合性を保証
- リポジトリでデータアクセスを抽象化
- 境界付けられたコンテキストを意識
- レイヤードアーキテクチャで関心事の細分化を意識

## 原則（フロントエンド）

### クリーンアーキテクチャ

- レイヤー分離の徹底
  - プレゼンテーション層：UI コンポーネントとイベントハンドラ
  - アプリケーション層：ユースケースとビジネスロジック
  - ドメイン層：ビジネスモデルと中核ロジック
  - データ層：APIクライアントやストレージアクセス
  - 各レイヤーがディレクトリ構造と一致するとは限らない
    - 採用されているフレームワークやライブラリのベストプラクティスを優先する

- 依存関係の方向性
  - 外側のレイヤーは内側のレイヤーに依存する
  - 内側のレイヤーは外側のレイヤーを知らない
  - 依存性逆転の原則により適切な抽象化を行う

- 責務の分離
  - UI コンポーネントはデータの表示と入力のみを担当
  - ビジネスロジックはプレゼンテーション層から分離
  - データ取得ロジックはリポジトリに集約

- ユースケース中心の設計
  - 機能ごとにユースケースを定義
  - 入力、処理、出力を明確に定義
  - ユースケース間の依存関係を最小化

- 依存性注入
  - 外部依存はインターフェースを通じて注入
  - テスト時にはモックに置き換え可能に
  - DIコンテナやプロバイダーを活用

### テスト駆動開発 (TDD)

- Red-Green-Refactorサイクル
- テストを仕様として扱う
- 小さな単位で反復
- 継続的なリファクタリング

## 実装手順

1. **型設計**
   - まず型を定義
   - ドメインの言語を型で表現

2. **純粋関数から実装**
   - 外部依存のない関数を先に
   - テストを先に書く

3. **副作用を分離**
   - IO操作は関数の境界に押し出す
   - 副作用を持つ処理をPromiseでラップ

4. **アダプター実装**
   - 外部サービスやDBへのアクセスを抽象化
   - テスト用モックを用意

## プラクティス

- 小さく始めて段階的に拡張
- 過度な抽象化を避ける
- コードよりも型を重視
- 複雑さに応じてアプローチを調整

## コードスタイル

- 関数優先（クラスは必要な場合のみ）
- 不変更新パターンの活用
- 早期リターンで条件分岐をフラット化
- エラーとユースケースの列挙型定義

## テスト戦略

- 純粋関数の単体テストを優先
- インメモリ実装によるリポジトリテスト
- テスト可能性を設計に組み込む
- アサートファースト：期待結果から逆算
